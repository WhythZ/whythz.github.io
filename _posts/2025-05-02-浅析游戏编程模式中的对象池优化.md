---
# author:
title: 浅析游戏编程模式中的对象池优化
description: >-
  以简化版的粒子系统为例介绍对象池的基本实现，简单介绍如何优化限制对象的查询时间复杂度，最后指出对象池与享元模式的区别
date: 2025-05-02 11:32:00 +0800
categories: [游戏开发, 玩法相关]
tags: [设计模式, 优化方法, C++]
# pin: true
# media_subpath: '/resources/'
# render_with_liquid: false
math: true
# mermaid: true
# image:
#   path: /resources/xxxxxx.png
#   lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#   alt: Responsive rendering of Chirpy theme on multiple devices
---

## 一、对象池设计思路

### 1.1 应用场景
- 游戏开发常常会遇到需要频繁创建和销毁大量相同对象的场景（例如MC的粒子效果、塔防游戏的子弹、RTS的兵种单位），若不做任何特殊处理，其主要会导致以下性能问题
	- **频繁创建与销毁对象的性能开销较大**
	- 会导致出现**大量内存碎片**，累积之后可能导致游戏最终无法运行
		- 例如在连续空间上开辟1KB、2KB、4KB、3KB、1KB的五块空间
		- 然后将2KB和3KB的内存释放，此时获得了总空闲空间5KB，但二者并不相邻
		- 若此时想一次性开辟5KB空间，先前释放所得的5KB无法被使用，因为不连续
	- 同时创建巨量低价值的相同对象（如过多的粒子）可能导致瞬间消耗完所有可用内存，而导致**阻塞其它重要的执行需求**

### 1.2 粗略设计
- 对象池（Object Pool）核心设计思想如下
	- 创建对象时将对象储存在数组或栈等**内存连续的数据结构中**，这避免了内存碎片
	- 对象每次用完后**放回池中循环利用而非直接销毁**，这避免了内存的频繁分配销毁
	- 对象池地**容量具有上限**，这避免了意外地创建过量对象阻塞程序

### 1.3 细节设计

#### 1.3.1 容量问题
- 对象池的容量上限需根据游戏需求进行设置，更大的池子能提供更强的应对能力和时间效率，更小的池子能节省更多的内存空间
- 容量存在上限意味着同时只能激活固定数量的对象，当所有对象均处于繁忙状态时，我们就无法调出新的对象来使用了，对此我们有以下解决办法
	- **设置足够大的固定容量**：确保不会出现所有对象繁忙的状况，但这缺乏灵活性
	- **直接忽略新的请求**：例如对象池管理的粒子系统，若所有粒子都正在被使用，那么屏幕已经充满了闪动的图形，玩家并不会注意到下一个爆炸的粒子效果比不上现在这个的璀璨
	- **强制干掉一个使用中的对象**：例如对象池管理的音效播放系统，假设在音效池满时需播放新的声音效果，由于玩家通常对声音很敏感（我最近在玩堕落之主时就遇到过好几次打怪的时候突然没声儿、一会儿突然又有声儿了的情况），我们最好不应该直接忽略新的音效，更好的解决方法是**用新声音覆盖掉正在播放中最低音量的声音**，这样既不会引人注意了
	- **对原对象池进行扩容**：在游戏总体设计允许的内存灵活范围内，我们可以选择在运行时增加池子的大小，**并考虑当增加的内存不再需要时，池子是否需要缩回原来的大小**
	- **或者创建新的溢出池**：同理需考虑新池子是否应当在不再被需要时进行销毁

#### 1.3.2 池槽位尺寸
- 如果对象池中仅存储同一类型的对象，那么没有问题，但若在定义容器时指出存储的对象类型是某种基类，这就意味着容器中可能存入尺寸不一致的不同派生类对象
	- 所以我们在设计池子的槽位时，需确保每个槽位尺寸都能存入**最大的可能对象**，否则超过预期大小的对象将会占据下一个对象的内存空间，导致内存崩坏（定量的食物，有人少吃无妨，但有人多吃了就可能导致他人吃不饱）
- 如果派生类对象间的尺寸差异较大，那么每放进去一个小对象都是在浪费内存（好比租了一辆搬家用的大卡车来搬家，却只用它运了一箱矿泉水）
	- 在该情况下，可以考虑为每个派生类设立专门的对象池（好比大盘盛大菜、小盘装小菜）

#### 1.3.3 与GC的冲突
- 由于内存管理系统通常会处理不常用的对象内存碎片，所以在支持垃圾回收的系统中设计对象池时，应当注意这个潜在的冲突问题
	- 当对象池不应被整体销毁时：应确保对象池**阻止对象在暂时不需被使用时被GC真正地析构**
	- 当对象池应当被整体销毁时：应及时**清除对象池内的对象间可能存在的相互引用**，因为这会阻止垃圾回收器真正回收这些对象

## 二、对象池代码实现

### 2.1 简单粒子系统
- 此处以简化的粒子系统为例（仿真的粒子系统通常应用重力、风力、摩擦等物理效果，而此处不搞那么复杂，粒子仅在直线上移动几帧后从屏幕中清除即可），以下是粒子类的实现示意

```cpp
class Particle
{
private:
    //表示粒子可移动的次数，正整数表示处于使用状态，<=0表示处于闲置
    int framesLeft;

    //粒子的坐标模拟
    double x, y;
    //粒子每次移动时坐标各分量上的增量
    double xVel, yVel;

public:
    //默认构造函数，初始化粒子为闲置状态，应当使用专门的函数进行实际的初始化
    Particle() :framesLeft(0) {}

    //使用专门的初始化方法，而非重载构造函数，因为对象复用时无法触发构造函数
    void Init(double _x, double _y, double _xVel, double _yVel, int _lifetime)
    {
        framesLeft = _lifetime;
        x = _x; y = _y;
        xVel = _xVel; yVel = _yVel;
    }

    //模拟粒子对象的实际功能
    void Animate()
    {
        //繁忙则返回
        if (!InUse()) return;

        //可移动次数递减
        framesLeft--;
        //以增量进行移动模拟
        x += xVel; y += yVel;
    }

    //返回是否处于使用状态
    bool InUse() const
    {
        return framesLeft > 0;
    }
};
```

- 以下是粒子的对象池类实现示意

```cpp
class ParticlePool
{
private:
    //对象池的容量上限
    static const int POOL_SIZE = 100;

    //实际存储对象的连续内存容器，此处使用原生数组
    //此处为方便硬编码了数组容量，也可在堆区开辟动态数组（或使用模板参数）
    Particle particles[POOL_SIZE];

public:
    //提供粒子的调用方法
    void Create(double _x, double _y, double _xVel, double _yVel, int _lifetime)
    {
        //数组初始化时就由Particle的默认构造对象填满，此处只需从中找到一个闲置粒子即可
        for (int i = 0; i < POOL_SIZE; i++)
        {
            if (!particles[i].InUse())
            {
                //重新初始化其成员属性
                particles[i].Init(_x, _y, _xVel, _yVel, _lifetime);
                return;
            }
        }
        //在这个实现中，若没找到任何可用的粒子，就不创建新的粒子了
    }

    //统一更新所有对象的功能模拟
    void Animate()
    {
        for (int i = 0; i < POOL_SIZE; i++)
            particles[i].Animate();
    }
};
```

### 2.2 优化对象查找

#### 2.2.1 使用额外空间
- 在前文的实现中，对象池的`ParticlePool::Create`方法在调出新粒子时可能需遍历整个数组来找到一个空闲槽，这在池很大很满时会较慢，耗费$O(n)$时间复杂度
- 我们首先可以想到以空间换时间，维护一个和存储对象的数组等大的额外栈容器存储指向空闲对象的指针，在请求调出新对象时直接从该栈顶弹出即可，仅耗费$O(1)$时间复杂度

#### 2.2.2 使用闲置空间
- 在前面的思路基础上还可以选择继续对空间进行优化（如果你觉得有必要的话），那就是征用闲置对象自身的空间用来代替栈结构，但这需要我们改变对象的类定义
	- 将除`framesLeft`以外的所有成员变量转移到`live`结构中存储，后者连同粒子指针`next`一并存储在联合体`union`的对象`state`中（联合体允许在同一块内存中存储不同数据类型，但同时只能使用其中一种类型的值）
		- 当粒子正在被使用时，该粒子对象使用的是`union`对象`state`中的`live`结构中的数据
		- 当粒子处于闲置状态且正被试图唤醒重用时，`state`的另一部分`next`成员被使用，其保留了指向当前粒子后方的一个可用粒子对象的指针，若无则是`nullptr`
	- 然后提供外界（对象池）读写私有成员`next`的方法函数，用于在每个粒子被征用和进入闲置时维护好`next`指针

```cpp
class Particle
{
private:
    //表示粒子可移动的次数，正整数表示处于使用状态，<=0表示处于闲置
    int framesLeft = 0;

    // //粒子的坐标模拟
    // double x, y;
    // //粒子每次移动时坐标各分量上的增量
    // double xVel, yVel;

    //联合体对象state可以在结构体对象live和粒子指针next二者间切换
    union
    {
        //使用时的状态
        struct
        {
            double x = 0, y = 0;
            double xVel = 0, yVel = 0;
        } live;

        //闲置而可被重用时的状态
        Particle* next = nullptr;
    } state;

public:
    //默认构造函数，初始化粒子为闲置状态，应当使用专门的函数进行实际的初始化
    Particle() :framesLeft(0) {}

    //使用专门的初始化方法，而非重载构造函数，因为对象复用时无法触发构造函数
    void Init(double _x, double _y, double _xVel, double _yVel, int _lifetime)
    {
        framesLeft = _lifetime;
        state.live.x = _x;
        state.live.y = _y;
        state.live.xVel = _xVel;
        state.live.yVel = _yVel;
    }

    //模拟粒子对象的实际功能
    void Animate()
    {
        //繁忙则返回
        if (!InUse()) return;

        //可移动次数递减
        framesLeft--;
        //以增量进行移动模拟
        state.live.x += state.live.xVel;
        state.live.y += state.live.yVel;
    }

    //设置下一个闲置粒子对象指针
    void SetNext(Particle* _next)
    {
        state.next = _next;
    }

    //获取下一个闲置粒子对象指针
    Particle* GetNext() const
    {
        return state.next;
    }

    //返回是否处于使用状态
    bool InUse() const
    {
        return framesLeft > 0;
    }
};
```

- 然后我们就可以（在对象池的类定义中）使用这些指针构建一个闲置粒子对象的链表，相当于征用了死亡粒子本身的内存，这种优化空间占用的方式称为[FreeList](http://en.wikipedia.org/wiki/Free_list)
	- 维护闲置粒子对象链表的头节点
	- 在对象池构造函数中初始化链表
	- 修改`Create`函数查找闲置对象的逻辑

```cpp
class ParticlePool
{
private:
    //对象池的容量上限
    static const int POOL_SIZE = 100;

    //实际存储对象的连续内存容器，此处使用原生数组
    //此处为方便硬编码了数组容量，也可在堆区开辟动态数组（或使用模板参数）
    Particle particles[POOL_SIZE];

    //维护闲置对象链表的头节点
    Particle* freeHead = nullptr;

public:
    ParticlePool()
    {
        //指向第一个可用的粒子
        freeHead = &particles[0];

        //每个粒子对象指向下一个
        for (int i = 0; i < POOL_SIZE - 1; i++)
            particles[i].SetNext(&particles[i + 1]);

        //末尾粒子对象指向nullptr
        particles[POOL_SIZE - 1].SetNext(nullptr);
    }
    
    //提供粒子的调用方法
    void Create(double _x, double _y, double _xVel, double _yVel, int _lifetime)
    {
        // //数组初始化时就由Particle的默认构造对象填满，此处只需从中找到一个闲置粒子即可
        // for (int i = 0; i < POOL_SIZE; i++)
        // {
        //     if (!particles[i].InUse())
        //     {
        //         //重新初始化其成员属性
        //         particles[i].Init(_x, _y, _xVel, _yVel, _lifetime);
        //         return;
        //     }
        // }

        //使用链表查找闲置对象，先保证池没有满
        if (freeHead != nullptr)
        {
            //取用当前头节点并将其从闲置链表移除，转移freeHead到下一位
            Particle* _newParticle = freeHead;
            freeHead = _newParticle->GetNext();
            //使用这个调出的新节点
            _newParticle->Init(_x, _y, _xVel, _yVel, _lifetime);
        }
        else
        {
            //池子满了，你可以按照需求选择应对策略，此处啥也不干
        }
    }

    //统一更新所有对象的功能模拟，并维护闲置粒子对象链表
    void Animate()
    {
        // for (int i = 0; i < POOL_SIZE; i++)
        //     particles[i].Animate();

        for (int i = 0; i < POOL_SIZE; i++)
        {
            //查找闲置粒子
            if (!particles[i].InUse())
            {
                //将粒子加到链表前部
                particles[i].SetNext(freeHead);
                freeHead = &particles[i];
            }
            //否则正常更新
            else
                particles[i].Animate();
        }
    }
};
```

- 如此便实现了常量级的查询时间，且并未使用额外的空间，代价是粒子类的复杂度提高

### 2.3 封装池与对象
- 如果对象池只专门存储一类对象，那么二者相耦合，可以进一步加强对象与池的封装
	- 将类对象的构造函数、专门的初始化方法、查询活跃状态方法等均**封装为私有**
	- 仅对应的对象池拥有**通过友元访问**该类对象的权限，这杜绝了外界的意外访问

## 三、区别于享元模式
- 对象池优化与享元模式不同
	- 对象池旨在**复用创建成本高、生命周期短**的无状态（或每次取出会重置状态）对象
	- 享元模式旨在**存储需跨多个上下文共享的不可变对象**，以减少**共享资源的重复加载**（如游戏纹理、音效、3D模型等）